package server.Snake;

import client.Snake.Entity.Player;
import server.Snake.Interface.IObserver;
import server.Snake.Interface.ISubject;
import server.Snake.Enums.EPacketHeader;
import server.Snake.Utility.BitmapConverter;
import server.Snake.Utility.Utils;

import java.awt.*;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadLocalRandom;

public class MatchInstance implements Runnable, ISubject {
    private static int concurrentThreads = 5;
    private Map<String, Player> players = new ConcurrentHashMap<>(); // All current players
    private Map<Integer, Handler> handlers = new ConcurrentHashMap<>(); // All opened socket's to clients

    private GameLogic gameLogic;
    private int[][] terrain;
    private int maxPlayerCount = 2;
    private int currentPlayerCount = 0;

    private boolean gameStarted = false;

    public MatchInstance() {
        this.terrain = BitmapConverter.BMPToIntArray("img/arena_test_01.png", 50, 50);
        this.gameLogic = new GameLogic(this.handlers, this.players, this.terrain);
    }

    public int getCurrentPlayerCount() {
        return this.currentPlayerCount;
    }

    public int getMaxPlayerCount() {
        return this.maxPlayerCount;
    }

    public boolean isGameStarted() {
        return gameStarted;
    }

    private Player createPlayer(String id) {
        if(players.containsKey(id)) {
            System.out.println("Player already exists.");
            return null;
        }
        int randX = ThreadLocalRandom.current().nextInt(5, 45);
        int randY = ThreadLocalRandom.current().nextInt(5, 45);

        while(terrain[randY][randX] == 6) { // To make sure that player doesn't spawn in a Wall already
            randX = ThreadLocalRandom.current().nextInt(5, 45);
            randY = ThreadLocalRandom.current().nextInt(5, 45);
        }

        // This could be improved by some more fancier initial position assignment
        Player player = new Player(id, randX, randY);

        Random rand = new Random();
        Color randomColor = new Color(rand.nextFloat(), rand.nextFloat(), rand.nextFloat());
        player.setColor(randomColor); // Assigning a random color for the player

        this.gameLogic.addPlayer(player); // Adding new client user to the players' pool
        return player;
    }

    @Override
    public void run() {
        var pool = Executors.newFixedThreadPool(concurrentThreads);
        pool.execute(gameLogic);
        while(true){
            if(currentPlayerCount != maxPlayerCount) {
                try {Thread.sleep(1000);} catch (Exception e) { };
                continue;
            }

            if(!gameStarted){
                handlers.forEach((index, handler) -> { // Setting and starting up all handlers
                    handler.setMatchInstance(this);
                    handler.setGameLogic(this.gameLogic);
                    handler.setPlayers(this.players);
                    pool.execute(handler);
                });

                handlers.forEach((id, handlers) -> {
                    String randId = Utils.randomId();
                    handlers.sendLoginInfo(randId, createPlayer(randId)); // Sending client it's info generated by server
                    for (int i = 0; i < terrain.length; i++) { // Going through all vertical lines of generated terrain
                        handlers.sendPacket(EPacketHeader.TERRAIN, BitmapConverter.intArrayToJSON(this.terrain, i)); // Sending terrain data
                    }
                });

                gameStarted = true;
            }
            try {Thread.sleep(100);} catch (Exception e) { };
        }
    }

    @Override
    public boolean registerObserver(IObserver o) {
        if(this.currentPlayerCount < this.maxPlayerCount){
            handlers.put(currentPlayerCount, (Handler)o);
            this.currentPlayerCount++;
            return true;
        }
        return false;
    }

    @Override
    public boolean unregisterObserver(IObserver o) {
        handlers.remove(o);
        return true;
    }

    @Override
    public boolean notifyObservers() {
        try {
            handlers.forEach((index, handler) -> {
                handler.update();
            });
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
